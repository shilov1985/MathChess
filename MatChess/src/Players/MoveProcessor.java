package Players;

import java.awt.Color;
import java.util.LinkedList;
import java.util.List;

import Board.ChessBoard;
import Board.PieceSetup;
import Players.Move.MOVE_PURPOSE;
import Players.Rules.BishopRules;
import Players.Rules.KingRules;
import Players.Rules.KnightRules;
import Players.Rules.MOVES_TYPE;
import Players.Rules.MOVE_DIRECTION;
import Players.Rules.PawnRules;
import Players.Rules.QueenRules;
import Players.Rules.RookRules;

/**
 * This class compute legal moves for every piece and color fill all legal
 * positions.It works ruled by the Rules class. During the process is not
 * possible to get a move which cause a self chess.The method
 * "getPieceLegalMoves" get the legal moves for one piece but when we put it in
 * cycle we get the all legal moves of all pieces- use of "getAllLegalMoves".
 * 
 * Every Move is generated by its "MOVE_TYPE "".
 */
public class MoveProcessor {

	private ChessBoard board;

	public ChessBoard getBoard() {
		return board;
	}

	private PieceSetup army;
	private long[][] TO_BINARY_POSITIONS;

	public MoveProcessor(ChessBoard board) {
		this.board = board;
		setArmy(board.getSetup());
		TO_BINARY_POSITIONS = board.TO_BINARY_POSITIONS;
	}

	public void getMovesForOnePiece(List<Move> moves, int startX, int startY, boolean isPaintMove,
			MOVES_TYPE computeType) {

		if (board.isAFriendAt(TO_BINARY_POSITIONS[startX][startY])) {

			long bPosS = TO_BINARY_POSITIONS[startX][startY];

			if (getArmy().isWRook(bPosS) || getArmy().isBRook(bPosS)) {

				RookRules.computeMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY, isPaintMove,
						computeType);

			} else if (getArmy().isWQueen(bPosS) || getArmy().isBQueen(bPosS)) {

				QueenRules.computeMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY, isPaintMove,
						computeType);

			} else if (getArmy().isWBishop(bPosS) || getArmy().isBBishop(bPosS)) {

				BishopRules.computeMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY, isPaintMove,
						computeType);

			} else if (getArmy().isWKnignt(bPosS) || getArmy().isBKnignt(bPosS)) {

				KnightRules.computeMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY, isPaintMove,
						computeType);

			} else if (getArmy().isWKing(bPosS) || getArmy().isBKing(bPosS)) {

				KingRules.computeMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY, isPaintMove,
						computeType);

			} else if (getArmy().isWPawn(bPosS)) {

				PawnRules.computeWhiteMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY,
						isPaintMove, computeType);

			} else if (getArmy().isBPawn(bPosS)) {

				PawnRules.computeBlackMoves(this, moves, TO_BINARY_POSITIONS[startX][startY], startX, startY,
						isPaintMove, computeType);

			}
		}

	}

	private void generateMoves(Rules rule, long from, long to, MOVE_PURPOSE moveType, List<Move> moves, int startX,
			int startY, boolean isPaintMove, Color color, MOVES_TYPE compType) {

		if (compType.equals(MOVES_TYPE.CHECK_PREVENTED)) {

			boolean isFormMove = true;

			if (moveType.equals(MOVE_PURPOSE.CASTLING)) {
				if (rule.isInCheck(board)) {
					isFormMove = false;
				}
				if (to == 2L) {

					Move mo = new Move(board, from, to << 1, MOVE_PURPOSE.FREE, rule);
					mo.execute();

					if (rule.isInCheck(board)) {
						isFormMove = false;
					}

					mo.undo();
				} else if (to == 32L) {
					Move mo = new Move(board, from, to >> 1, MOVE_PURPOSE.FREE, rule);
					mo.execute();
					if (rule.isInCheck(board)) {
						isFormMove = false;
					}
					mo.undo();
				}
			}

			if (isFormMove) {

				Move mo = new Move(board, from, to, moveType, rule);
				mo.execute();

				// Not possible to generate move that put us in self check.
				if (!rule.isInCheck(board)) {

					mo.undo();
					moves.add(mo);

					if (isPaintMove) {
						board.getBoardCells()[startX][startY].setPointColor(color);
					}

				} else {
					mo.undo();
				}
			}
		} else if (compType.equals(MOVES_TYPE.ALL)) {

			Move mo = new Move(board, from, to, moveType, rule);
			moves.add(mo);
		}
	}

	// This recursive method get the legal moves from start to end
	// position.During this we use Rules to determine the type of the move and
	// its behaviors.
	public List<Move> getMoves(List<Move> moves, Rules rule, long from, int startX, int startY, int range,
			boolean isPaintMove, MOVE_DIRECTION dir, MOVES_TYPE compType) {

		// Here we set the bottom of the recursion by "isMoveOver" method.
		if (rule.isMoveOver(startX, startY, range, dir)) {
			return moves;
		}

		long to = TO_BINARY_POSITIONS[startX][startY];

		if (rule.isMoveCastling(board, from, to, dir)) {

			generateMoves(rule, from, to, MOVE_PURPOSE.CASTLING, moves, startX, startY, isPaintMove, Color.orange,
					compType);

		} else if (rule.isMovePromotion(board, from, to, dir)) {

			generateMoves(rule, from, to, MOVE_PURPOSE.PROMOTION, moves, startX, startY, isPaintMove, Color.yellow,
					compType);

		} else if (rule.isMoveEnpassant(board, from, to, dir)) {

			generateMoves(rule, from, to, MOVE_PURPOSE.ENPASSANT, moves, startX, startY, isPaintMove, Color.cyan,
					compType);

		} else if (rule.isMoveFree(board, from, to, dir)) {

			generateMoves(rule, from, to, MOVE_PURPOSE.FREE, moves, startX, startY, isPaintMove, Color.green, compType);

		} else if (rule.isMoveAttack(board, from, to, dir)) {

			generateMoves(rule, from, to, MOVE_PURPOSE.ATTACK, moves, startX, startY, isPaintMove, Color.red, compType);

			return moves;

		} else {
			return moves;
		}

		return getMoves(moves, rule, from, rule.updateX(startX, dir), rule.updateY(startY, dir),
				rule.updateRange(range, dir), isPaintMove, dir, compType);

	}

	public void geMovesOfAllPieces(List<Move> moves, MOVES_TYPE type) {

		for (int x = 0; x <= 7; x++) {
			for (int y = 0; y <= 7; y++) {

				getMovesForOnePiece(moves, x, y, false, type);
			}
		}

	}

	// turn two dimensional coordinate in to linear index
	// If X =0 and Y =0 output is 64
	// If X =7 and Y =7 output is 1
	// This is important because we must traverse a binary from end to the
	// start.
	public int toLinearPosition(int startX, int startY) {

		return 64 - ((startX * 8) + startY);
	}

	public void setArmy(PieceSetup army) {
		this.army = army;
	}

	public PieceSetup getArmy() {
		return army;
	}

	/**
	 * Calculate only the enemy moves that can capture my piece, but not free
	 * moves.Needed for "Rules.isInCheck" method
	 * 
	 * @see "Rules.isInCheck"
	 * 
	 */

	public long getAllAffectiveEnemyMovesMask() {

		board.swapPlayers();
		List<Move> moves = new LinkedList<Move>();
		board.getMoveProcessor().geMovesOfAllPieces(moves, MOVES_TYPE.ALL);

		long m = 0l;

		for (Move mo : moves) {
			m = m | mo.getDestPos();
		}
		board.swapPlayers();
		return m;
	}

}
